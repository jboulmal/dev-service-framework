{"version":3,"sources":["idp/IdpProxyStub.js"],"names":["_classCallCheck","instance","Constructor","TypeError","urlParser","url","name","replace","regexS","regex","RegExp","results","exec","sendHTTPRequest","method","xhr","XMLHttpRequest","open","XDomainRequest","Promise","resolve","reject","onreadystatechange","e","readyState","status","info","JSON","parse","responseText","send","activate","bus","config","IdpProxyProtoStub","Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","identities","nIdentity","googleInfo","clientSecret","clientID","redirectURI","location","protocol","hostname","issuer","tokenEndpoint","jwksUri","authorisationEndpoint","userinfo","tokenInfo","accessType","type","scope","state","exchangeCode","code","URL","then","error","IdpProxy","validateAssertion","assertion","origin","decodedContent","atob","content","idTokenSplited","tokenID","split","idToken","identity","email","contents","generateAssertion","hint","infoTokenURL","access_token","infoToken","identityBundle","accessToken","id_token","refreshToken","refresh_token","tokenType","token_type","idTokenURL","tokenIDJSON","expires","exp","btoa","stringify","idpBundle","domain","returnValue","idp","err","requestUrl","loginUrl","runtimeProtoStubURL","this","_this","messageBus","addListener","msg","to","requestToIdp","params","body","usernameHint","replyMessage","message","id","from","postMessage","module"],"mappings":"AAAA,YAA6lB,SAASA,iBAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAoBvsB,QAASC,WAAUC,EAAKC,GACtBA,EAAOA,EAAKC,QAAQ,OAAQ,OAAQA,QAAQ,OAAQ,MACpD,IAAIC,GAAS,UAAYF,EAAO,YAC5BG,EAAQ,GAAIC,QAAOF,GACnBG,EAAUF,EAAMG,KAAKP,EACzB,OAAgB,QAAZM,EACG,GAEAA,EAAQ,GAGjB,QAASE,iBAAgBC,EAAQT,GAC/B,GAAIU,GAAM,GAAIC,eAYd,OAXI,mBAAqBD,GACvBA,EAAIE,KAAKH,EAAQT,GAAK,GACY,mBAAlBa,iBAGhBH,EAAM,GAAIG,gBACVH,EAAIE,KAAKH,EAAQT,IAGjBU,EAAM,KAED,GAAII,SAAQ,SAASC,EAAQC,GAC9BN,GACFA,EAAIO,mBAAqB,SAASC,GAChC,GAAuB,IAAnBR,EAAIS,WACN,GAAmB,MAAfT,EAAIU,OAAgB,CACtB,GAAIC,GAAOC,KAAKC,MAAMb,EAAIc,aAC1BT,GAAQM,OAERL,GADwB,MAAfN,EAAIU,OACN,0CAEA,+CAIbV,EAAIe,QAEJT,EAAO,wBA2OE,QAASU,UAAS1B,EAAK2B,EAAKC,GACzC,OACE3B,KAAM,oBACNL,SAAU,GAAIiC,mBAAkB7B,EAAK2B,EAAKC,IA1SjCE,OAAOC,eAAeC,QAAQ,cAAcC,OAAM,GAAO,IAAIC,cAAa,WAAW,QAASC,GAAiBC,EAAOC,GAAO,IAAI,GAAIC,GAAE,EAAEA,EAAED,EAAME,OAAOD,IAAI,CAAC,GAAIE,GAAWH,EAAMC,EAAGE,GAAWC,WAAWD,EAAWC,aAAY,EAAMD,EAAWE,cAAa,EAAQ,SAAUF,KAAWA,EAAWG,UAAS,GAAKb,OAAOC,eAAeK,EAAOI,EAAWI,IAAIJ,IAAc,MAAO,UAAS3C,EAAYgD,EAAWC,GAAuI,MAAvHD,IAAWV,EAAiBtC,EAAYkD,UAAUF,GAAeC,GAAYX,EAAiBtC,EAAYiD,GAAoBjD,KAAkBmC,SAAAA,WAuS5iBN,QAvSxB,IAAIsB,eACAC,UAAY,EAEZC,YACFC,aAAuB,2BACvBC,SAAuB,2EACvBC,YAAuBC,SAASC,SAAW,KAAOD,SAASE,SAC3DC,OAAuB,8BACvBC,cAAuB,8CACvBC,QAAuB,8CACvBC,sBAAuB,6CACvBC,SAAuB,8DACvBC,UAAuB,2DACvBC,WAAuB,UACvBC,KAAuB,sBACvBC,MAAuB,2BACvBC,MAAuB,SAqDrBC,aAAgB,SAASC,GAC3B,GAAI9B,GAAIY,WAEJmB,EAAM/B,EAAEoB,cAAgB,QAAUU,EAAO,cAAgB9B,EAAEc,SAAW,kBAAoBd,EAAEa,aAAe,iBAAmBb,EAAEe,YAAc,gCAIlJ,OAAO,IAAIvC,SAAQ,SAASC,EAASC,GACnCR,gBAAgB,OAAQ6D,GAAKC,KAAK,SAASjD,GACzCN,EAAQM,IACP,SAASkD,GACVvD,EAAOuD,QASTC,UAUFC,kBAAmB,SAACC,EAAWC,GAG7B,MAAO,IAAI7D,SAAQ,SAASC,EAAQC,GAElC,GAAI4D,GAAiBC,KAAKH,GACtBI,EAAUxD,KAAKC,MAAMqD,GAErBG,EAAiBD,EAAQE,QAAQC,MAAM,KAEvCC,EAAU5D,KAAKC,MAAMsD,KAAKE,EAAe,IAE7ChE,IAASoE,SAAUD,EAAQE,MAAOC,SAAUH,OA+BhDI,kBAAmB,SAACD,EAAUV,EAAQY,GACpC,GAAIjD,GAAIY,UAIR,OAAO,IAAIpC,SAAQ,SAASC,EAASC,GACnC,GAAKuE,EAaE,CAEL,GAEInB,IAFcrE,UAAUwF,EAAM,gBACpBxF,UAAUwF,EAAM,YACnBxF,UAAUwF,EAAM,QAE3BpB,cAAaC,GAAME,KAAK,SAASrC,GAG/B,GAAIuD,GAAelD,EAAEuB,SAAW5B,EAAMwD,YACtCjF,iBAAgB,MAAOgF,GAAclB,KAAK,SAASoB,GAEjD,GAAIC,IAAkBC,YAAa3D,EAAMwD,aAAcP,QAASjD,EAAM4D,SAAUC,aAAc7D,EAAM8D,cAAeC,UAAW/D,EAAMgE,WAAYP,UAAWA,GAEvJQ,EAAa5D,EAAEwB,UAAY7B,EAAM4D,QAGrCrF,iBAAgB,MAAO0F,GAAY5B,KAAK,SAASY,GAI/CS,EAAeQ,YAAcjB,EAC7BS,EAAeS,QAAUlB,EAAQmB,IACjCV,EAAeP,MAAQF,EAAQE,KAE/B,IAAIV,GAAY4B,KAAKhF,KAAKiF,WAAWvB,QAAS/C,EAAM4D,SAAUM,YAAajB,KACvEsB,GAAaC,OAAQ,aAAclD,SAAU,QAG7CmD,GAAehC,UAAWA,EAAWiC,IAAKH,EAAWnF,KAAMsE,EAAgBD,UAAWA,EAE1F1C,YAAWC,WAAayD,IACtBzD,UAEFlC,EAAQ2F,IACP,SAASxF,GAEVF,EAAOE,MAER,SAASqD,GAEVvD,EAAOuD,MAER,SAASqC,GAEV5F,EAAO4F,SA1DA,CAOT,GAAIC,GAAavE,EAAEsB,sBAAwB,SAAWtB,EAAE2B,MAAQ,cAAgB3B,EAAEc,SAAW,iBAAmBd,EAAEe,YAAc,kBAAoBf,EAAE0B,KAAO,UAAY1B,EAAE4B,MAAQ,gBAAkB5B,EAAEyB,WAAa,UAAYsB,CAEhOrE,IAAQf,KAAM,gBAAiB6G,SAAUD,SA4D3ChF,kBAjKkB,WA2KvB,QAAAA,GAAYkF,EAAqBpF,EAAKC,GAAQjC,gBAAAqH,KAAAnF,EAC5C,IAAIoF,GAAQD,IACZC,GAAMF,oBAAsBA,EAC5BE,EAAMC,WAAavF,EACnBsF,EAAMrF,OAASA,EAEfqF,EAAMC,WAAWC,YAAY,IAAK,SAASC,GAC1B,4BAAXA,EAAIC,IAENJ,EAAMK,aAAaF,KApK6L,MALnNlF,cAAaL,IAAoBe,IAAI,eAAeX,MAAM,SAmL/CmF,GACX,GAAIH,GAAQD,KACRO,EAASH,EAAII,KAAKD,MAEtB,QAAQH,EAAII,KAAK/G,QACf,IAAK,oBACH+D,SAASc,kBAAkBiC,EAAOlC,SAAUkC,EAAO5C,OAAQ4C,EAAOE,cAAcnD,KAC9E,SAASrC,GAASgF,EAAMS,aAAaN,EAAKnF,IAE1C,SAASsC,GAAS0C,EAAMS,aAAaN,EAAK7C,IAE5C,MACF,KAAK,oBACHC,SAASC,kBAAkB8C,EAAO7C,UAAW6C,EAAO5C,QAAQL,KAC1D,SAASrC,GAASgF,EAAMS,aAAaN,EAAKnF,IAE1C,SAASsC,GAAS0C,EAAMS,aAAaN,EAAK7C,SA9L7C3B,IAAI,eAAeX,MAAM,SA4MjBmF,EAAKnF,GAChB,GAAIgF,GAAQD,KAERW,GAAWC,GAAIR,EAAIQ,GAAI5D,KAAM,WAAYqD,GAAID,EAAIS,KAAMA,KAAMT,EAAIC,GACtDG,MAAOpD,KAAM,IAAKnC,MAAOA,GAExCgF,GAAMC,WAAWY,YAAYH,OAlN6L9F,IAOxGkG,QAAO/F,QAAQA,QAAQ","file":"idp/IdpProxyStub.js","sourcesContent":["let identities = {};\nlet nIdentity = 0;\n\nlet googleInfo = {\n  clientSecret:          'Xx4rKucb5ZYTaXlcZX9HLfZW',\n  clientID:              '808329566012-tqr8qoh111942gd2kg007t0s8f277roi.apps.googleusercontent.com',\n  redirectURI:           location.protocol + '//' + location.hostname, //location.origin,\n  issuer:                'https://accounts.google.com',\n  tokenEndpoint:         'https://www.googleapis.com/oauth2/v4/token?',\n  jwksUri:               'https://www.googleapis.com/oauth2/v3/certs?',\n  authorisationEndpoint: 'https://accounts.google.com/o/oauth2/auth?',\n  userinfo:              'https://www.googleapis.com/oauth2/v3/userinfo?access_token=',\n  tokenInfo:             'https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=',\n  accessType:            'offline',\n  type:                  'code token id_token',\n  scope:                 'openid%20email%20profile',\n  state:                 'state'\n};\n\n//function to parse the query string in the given URL to obatin certain values\nfunction urlParser(url, name) {\n  name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\n  let regexS = '[\\\\#&?]' + name + '=([^&#]*)';\n  let regex = new RegExp(regexS);\n  let results = regex.exec(url);\n  if (results === null)\n  return '';\n  else\n  return results[1];\n}\n\nfunction sendHTTPRequest(method, url) {\n  let xhr = new XMLHttpRequest();\n  if ('withCredentials' in xhr) {\n    xhr.open(method, url, true);\n  } else if (typeof XDomainRequest != 'undefined') {\n    // Otherwise, check if XDomainRequest.\n    // XDomainRequest only exists in IE, and is IE's way of making CORS requests.\n    xhr = new XDomainRequest();\n    xhr.open(method, url);\n  } else {\n    // Otherwise, CORS is not supported by the browser.\n    xhr = null;\n  }\n  return new Promise(function(resolve,reject) {\n    if (xhr) {\n      xhr.onreadystatechange = function(e) {\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            let info = JSON.parse(xhr.responseText);\n            resolve(info);\n          } else if (xhr.status === 400) {\n            reject('There was an error processing the token');\n          } else {\n            reject('something else other than 200 was returned');\n          }\n        }\n      };\n      xhr.send();\n    } else {\n      reject('CORS not supported');\n    }\n  });\n}\n\n/**\n* Function to exchange the code received to the id Token, access token and a refresh token\n*\n*/\nlet exchangeCode = (function(code) {\n  let i = googleInfo;\n\n  let URL = i.tokenEndpoint + 'code=' + code + '&client_id=' + i.clientID + '&client_secret=' + i.clientSecret + '&redirect_uri=' + i.redirectURI + '&grant_type=authorization_code';\n\n  //let URL = = i.tokenEndpoint + 'client_id=' + i.clientID + '&client_secret=' + i.clientSecret + '&refresh_token=' + code + '&grant_type=refresh_token';\n\n  return new Promise(function(resolve, reject) {\n    sendHTTPRequest('POST', URL).then(function(info) {\n      resolve(info);\n    }, function(error) {\n      reject(error);\n    });\n\n  });\n});\n\n/**\n* Identity Provider Proxy\n*/\nlet IdpProxy = {\n\n  /**\n  * Function to validate an identity Assertion received\n  * TODO add details of the implementation, and improve the implementation\n  *\n  * @param  {assertion}    Identity Assertion to be validated\n  * @param  {origin}       Origin parameter that identifies the origin of the RTCPeerConnection\n  * @return {Promise}      Returns a promise with the identity assertion validation result\n  */\n  validateAssertion: (assertion, origin) => {\n\n    //TODO check the values with the hash received\n    return new Promise(function(resolve,reject) {\n\n      let decodedContent = atob(assertion);\n      let content = JSON.parse(decodedContent);\n\n      let idTokenSplited = content.tokenID.split('.');\n\n      let idToken = JSON.parse(atob(idTokenSplited[1]));\n\n      resolve({identity: idToken.email, contents: idToken});\n\n    });\n    /*return new Promise(function(resolve,reject) {\n      let i = googleInfo;\n\n      let decodedContent = atob(assertion);\n      let content = JSON.parse(decodedContent);\n      sendHTTPRequest('GET', i.tokenInfo + content.tokenID).then(function(result) {\n\n        if (JSON.stringify(result) === JSON.stringify(content.tokenIDJSON)) {\n          resolve({identity: content.tokenIDJSON.email, contents: content.tokenIDJSON});\n        } else {\n          reject('invalid');\n        }\n      }, function(err) {\n\n        reject(err);\n      });\n    });*/\n  },\n\n  /**\n  * Function to generate an identity Assertion\n  * TODO add details of the implementation, and improve implementation\n  *\n  * @param  {contents} The contents includes information about the identity received\n  * @param  {origin} Origin parameter that identifies the origin of the RTCPeerConnection\n  * @param  {usernameHint} optional usernameHint parameter\n  * @return {Promise} returns a promise with an identity assertion\n  */\n  generateAssertion: (contents, origin, hint) => {\n    let i = googleInfo;\n\n    //start the login phase\n    //TODO later should be defined a better approach\n    return new Promise(function(resolve, reject) {\n      if (!hint) {\n        /*try {\n          if (window) {\n            resolve('url');\n          }\n        } catch (error) {*/\n\n        let requestUrl = i.authorisationEndpoint + 'scope=' + i.scope + '&client_id=' + i.clientID + '&redirect_uri=' + i.redirectURI + '&response_type=' + i.type + '&state=' + i.state + '&access_type=' + i.accessType + '&nonce=' + contents;\n\n        reject({name: 'IdPLoginError', loginUrl: requestUrl});\n\n      //  }\n\n      } else {\n        // the request have already been made, so idpPRoxy will exchange the tokens along to the idp, to obtain the information necessary\n        let accessToken = urlParser(hint, 'access_token');\n        let idToken = urlParser(hint, 'id_token');\n        let code = urlParser(hint, 'code');\n\n        exchangeCode(code).then(function(value) {\n\n          //obtain information about the user\n          let infoTokenURL = i.userinfo + value.access_token;\n          sendHTTPRequest('GET', infoTokenURL).then(function(infoToken) {\n\n            let identityBundle = {accessToken: value.access_token, idToken: value.id_token, refreshToken: value.refresh_token, tokenType: value.token_type, infoToken: infoToken};\n\n            let idTokenURL = i.tokenInfo + value.id_token;\n\n            //obtain information about the user idToken\n            sendHTTPRequest('GET', idTokenURL).then(function(idToken) {\n\n\n\n              identityBundle.tokenIDJSON = idToken;\n              identityBundle.expires = idToken.exp;\n              identityBundle.email = idToken.email;\n\n              let assertion = btoa(JSON.stringify({tokenID: value.id_token, tokenIDJSON: idToken}));\n              let idpBundle = {domain: 'google.com', protocol: 'OIDC'};\n\n              //TODO delete later the field infoToken, and delete the need in the example\n              let returnValue = {assertion: assertion, idp: idpBundle, info: identityBundle, infoToken: infoToken};\n\n              identities[nIdentity] = returnValue;\n              ++nIdentity;\n\n              resolve(returnValue);\n            }, function(e) {\n\n              reject(e);\n            });\n          }, function(error) {\n\n            reject(error);\n          });\n        }, function(err) {\n\n          reject(err);\n        });\n\n      }\n    });\n  }\n};\n\n/**\n* Identity Provider Proxy Protocol Stub\n*/\nclass IdpProxyProtoStub {\n\n  /**\n  * Constructor of the IdpProxy Stub\n  * The constructor add a listener in the messageBus received and start a web worker with the idpProxy received\n  *\n  * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\n  * @param  {Message.Message}                           busPostMessage     configuration\n  * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\n  */\n constructor(runtimeProtoStubURL, bus, config) {\n   let _this = this;\n   _this.runtimeProtoStubURL = runtimeProtoStubURL;\n   _this.messageBus = bus;\n   _this.config = config;\n\n   _this.messageBus.addListener('*', function(msg) {\n     if (msg.to === 'domain-idp://google.com') {\n\n       _this.requestToIdp(msg);\n     }\n   });\n }\n\n  /**\n  * Function that see the intended method in the message received and call the respective function\n  *\n  * @param {message}  message received in the messageBus\n  */\n  requestToIdp(msg) {\n    let _this = this;\n    let params = msg.body.params;\n\n    switch (msg.body.method) {\n      case 'generateAssertion':\n        IdpProxy.generateAssertion(params.contents, params.origin, params.usernameHint).then(\n          function(value) { _this.replyMessage(msg, value);},\n\n          function(error) { _this.replyMessage(msg, error);}\n        );\n        break;\n      case 'validateAssertion':\n        IdpProxy.validateAssertion(params.assertion, params.origin).then(\n          function(value) { _this.replyMessage(msg, value);},\n\n          function(error) { _this.replyMessage(msg, error);}\n        );\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n  * This function receives a message and a value. It replies the value to the sender of the message received\n  *\n  * @param  {message}   message received\n  * @param  {value}     value to include in the new message to send\n  */\n  replyMessage(msg, value) {\n    let _this = this;\n\n    let message = {id: msg.id, type: 'response', to: msg.from, from: msg.to,\n                   body: {code: 200, value: value}};\n\n    _this.messageBus.postMessage(message);\n  }\n}\n\n// export default IdpProxyProtoStub;\n\n/**\n * To activate this protocol stub, using the same method for all protostub.\n * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\n * @param  {Message.Message}                           busPostMessage     configuration\n * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\n * @return {Object} Object with name and instance of ProtoStub\n */\nexport default function activate(url, bus, config) {\n  return {\n    name: 'IdpProxyProtoStub',\n    instance: new IdpProxyProtoStub(url, bus, config)\n  };\n}\n"],"sourceRoot":"/source/"}