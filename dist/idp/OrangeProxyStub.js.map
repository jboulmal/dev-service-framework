{"version":3,"sources":["idp/OrangeProxyStub.js"],"names":["_classCallCheck","instance","Constructor","TypeError","getProxyKey","Promise","resolve","reject","xmlhttp","XMLHttpRequest","onreadystatechange","readyState","status","res","JSON","parse","responseText","undefined","error","open","SOURCEURL","KEYPATH","send","getProxyID","key","IDPATH","getIdAssertion","str2ab","str","buf","ArrayBuffer","length","bufView","Uint8Array","i","strLen","charCodeAt","ab2str","String","fromCharCode","apply","activate","url","bus","config","name","RethinkOidcProtoStub","Object","defineProperty","exports","value","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","prototype","AUTHPATH","VERIFYPATH","DONEPATH","PROXYTYPE","IDSCOPE","FULLSCOPE","TYPE","idp_addr","domain","protocol","console","log","idp","generateAssertion","contents","then","ID","_url","Math","random","btoa","myInit","method","credentials","redirect","fetch","response","text","hash","dump","json","data","split","toString","assertion","id_token","loginURL","loginUrl","validateAssertion","header","payload","signature","replace","Key","crypto","subtle","importKey","JWK","verify","atob","result","sub","identity","rtcsdp","Error","runtimeProtoStubURL","this","_this","messageBus","addListener","msg","to","requestToIdp","params","body","origin","usernameHint","replyMessage","message","id","type","from","code","postMessage","module"],"mappings":"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","file":"idp/OrangeProxyStub.js","sourcesContent":["/**\n* IdentityProxy -- NODE OPENID CONNECT Server\n*\n* Initial specification: D4.1\n*\n* The IdentityModule is a component managing user Identity. It downloads, instantiates\n* and manage Identity Provider Proxy (IdP) for its own user identity or for external\n* user identity verification.\n*\n* The IdP contains methods and parameters to actually access and make request\n* to the IdP Server. Alternatively some functionnalities can be done locally.\n*\n*/\nvar SOURCEURL = \"https://energyq.idp.rethink.orange-labs.fr\",\n    AUTHPATH = \"/proxy/authorize\",\n    VERIFYPATH = \"/proxy/verify\",\n    DONEPATH = \"/proxy/done\",\n    KEYPATH = '/proxy/key',\n    IDPATH = '/proxy/id',\n    PROXYTYPE = \"rethink-oidc\",\n    IDSCOPE = \"openid\",\n    FULLSCOPE = \"openid webrtc\",\n    TYPE       =   'id_token token';\n  //var TYPE       =   'code';\n\nvar idp_addr = {'domain': \"https://energyq.idp.rethink.orange-labs.fr\", 'protocol': PROXYTYPE}\n\nif (typeof console == \"undefined\") {\n    this.console = {\n        log: function () {}\n    };\n}\n\nfunction getProxyKey(){\n  return new Promise((resolve, reject) => {\n    var xmlhttp = new XMLHttpRequest()\n    xmlhttp.onreadystatechange = () => {\n      if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n        var res = JSON.parse(xmlhttp.responseText)\n        res.error != undefined ? reject(res.error) : resolve(res)\n      }\n    }\n    xmlhttp.open(\"GET\", SOURCEURL+KEYPATH, true)\n    xmlhttp.send()\n  })\n}function getProxyID(){\n   return new Promise((resolve, reject) => {\n     var xmlhttp = new XMLHttpRequest()\n     xmlhttp.onreadystatechange = () => {\n       if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n         var res = JSON.parse(xmlhttp.responseText)\n         res.error != undefined ? reject(res.error) : resolve(res.key)\n       }\n     }\n     xmlhttp.open(\"GET\", SOURCEURL+IDPATH, true)\n     xmlhttp.send()\n   })\n }\n function getIdAssertion(){\n   return new Promise((resolve, reject) => {\n     var xmlhttp = new XMLHttpRequest()\n     xmlhttp.onreadystatechange = () => {\n       if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n         var res = JSON.parse(xmlhttp.responseText)\n         res.error != undefined ? reject(res.error) : resolve(res.key)\n       }\n     }\n     xmlhttp.open(\"GET\", SOURCEURL+IDPATH, true)\n     xmlhttp.send()\n   })\n }\n function str2ab(str) {\n   var buf = new ArrayBuffer(str.length);\n   var bufView = new Uint8Array(buf);\n   for (var i=0, strLen=str.length; i < strLen; i++) {\n     bufView[i] = str.charCodeAt(i);\n   }\n   return buf;\n }\n\n function ab2str(buf) {\n   return String.fromCharCode.apply(null, new Uint8Array(buf));\n }\n\n// IDP Proxy code\nvar idp = {\n  /**\n  * Generation of an IdAssertion through OIDC IdP\n  */\n  generateAssertion: (contents /*, origin, hint */) => {\n  // TODO : sign contents in the Id Token\n    return new Promise((resolve, reject) =>\n      getProxyID()\n      .then(ID => {\n        var _url = SOURCEURL+AUTHPATH+'?scope=' + FULLSCOPE + '&client_id=' + ID +\n                     '&redirect_uri=' + SOURCEURL + DONEPATH + '&response_type=' + TYPE +\n                     '&nonce=' + 'N-'+Math.random() + '&rtcsdp='+btoa(contents)\n        var myInit = { method: 'GET',\n                     //headers: myHeaders,\n                       credentials: 'same-origin',\n                       // we don't follow redirect so that if user is not logged (redirect)\n                       // we get an error an can return login URL to the application\n                       redirect: 'error'};\n        //var urlW = 'https://localhost:8080/proxy/authorize?scope=openid&client_id=LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDY0Vnckx0WVRIUHAvdHFCQ3BUL1UwS1dJTQo0d2lkaGNFWEd1UkZCZDN3TlpPY0huMnRFanZaTkhmc3NvUXR0UjBOVEQ1USs5UGR0TWZJTFhxU3E3V3htMk5sCkNhNXJTVHpmT1k5NWhZQms3UVBZdTN6dEVQUHVOQ3B1Mld6QlQ2ZGg4YXpVOGUvRHZYV2RwbHpXdmpuTmduVGIKSHZOK01PWU84SGhLMkZWR2F3SURBUUFCCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo=&redirect_uri=https://localhost:8080/proxy/done&response_type=id_token%20token&nonce=N-0.9316785699162342'\n\n        fetch(_url,myInit)\n        .then(response => response.text())\n        .then(hash => {\n        dump(hash)\n          var json = {}\n          var data = hash.split('&').toString().split(/[=,]+/);\n          for(var i=0; i<data.length; i+=2){\n            json[data[i]]=data[i+1];\n          }\n\n          resolve({'assertion': json.id_token, 'idp': idp_addr})\n        })\n      })\n      .catch(error => {\n          // We just login but we could do something better maybe?\n          // Handling authorizations and such\n          var loginURL = SOURCEURL+'/login'\n          reject({'name': 'IdPLoginError', 'loginUrl': loginURL})\n      })\n//              // this will open a window with the URL which will open a page\n//              // sent by IdP for the user to insert the credentials\n//              // the IdP validates the credentials then send a access token\n//          window.open(_url, 'openIDrequest', 'width=800, height=600')\n//              // respond to events\n//          this.addEventListener('message', event => {\n//            if(event.origin !== SOURCEURL) return;\n//\n//            resolve(JSON.parse(event.data).id_token)\n//            //idp.validateAssertion(res.id_token).then(\n//            //    response => resolve(response), error => reject(error))\n//          },false)\n  )},\n  /**\n  * Verification of a received IdAssertion validity\n  * Can also be used to validate token received by IdP\n  * @param  {DOMString} assertion assertion\n  */\n  validateAssertion: (assertion /*, origin */) => {\n    assertion = assertion.split(\".\")\n    var header = assertion[0],\n        payload = assertion[1],\n        signature = assertion[2]\n    //TODO there is probably a better way to do that?\n    signature = signature.replace(/_/g, \"/\").replace(/-/g, \"+\")\n    return new Promise((resolve, reject) =>\n      getProxyKey()\n        .then(Key =>\n      crypto.subtle.importKey('jwk',Key,{ name: 'RSASSA-PKCS1-v1_5',hash: {name: \"SHA-256\"}},true, ['verify'])\n        .then(JWK =>\n      //crypto.verify(algo, key, signature, text2verify);\n      crypto.subtle.verify('RSASSA-PKCS1-v1_5',\n                           JWK,\n                           str2ab(atob(signature)),   //ArrayBuffer of the signature,\n                           str2ab(header+\".\"+payload))//ArrayBuffer of the data\n        .then(result => {\n      if (!result) reject(new Error('Invalid signature on identity assertion'))\n      else {\n        var json = JSON.parse(atob(payload))\n        // hack to get only the name and remove any @mail.com\n        // Mozilla want us to provide a username with name@DOMAIN\n        // where DOMAIN is IdP Proxy DOMAIN\n        var name = json.sub.split('@')[0]\n        resolve({'identity': name+'@'+idp_addr.domain, 'contents': atob(json.rtcsdp)})\n      }})))\n    )}\n}\n\n/*\nif (rtcIdentityProvider) {\n  rtcIdentityProvider.register(idp);\n  console.log(\"Proxy loaded\")\n} else {\n  console.warn('IdP not running in the right sandbox');\n}\n*/\n\n/**\n* Identity Provider Proxy Protocol Stub\n*/\nclass RethinkOidcProtoStub {\n\n  /**\n  * Constructor of the IdpProxy Stub\n  * The constructor add a listener in the messageBus received and start a web worker with the idpProxy received\n  *\n  * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\n  * @param  {Message.Message}                           busPostMessage     configuration\n  * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\n  */\n constructor(runtimeProtoStubURL, bus, config) {\n   let _this = this;\n   _this.runtimeProtoStubURL = runtimeProtoStubURL;\n   _this.messageBus = bus;\n   _this.config = config;\n\n   _this.messageBus.addListener('*', function(msg) {\n     if (msg.to == 'domain-idp://orange.com') {\n       /*let newValue = IdpProxy.generateAssertion();\n       let message = {id: msg.id, type: 'response', to: msg.from, from: msg.to,\n                      body: {code: 200, value: newValue, bus: bus, runtimeProtoStubURL: runtimeProtoStubURL}};\n\n       _this.messageBus.postMessage(message);*/\n       _this.requestToIdp(msg);\n     }\n   });\n }\n\n  /**\n  * Function that see the intended method in the message received and call the respective function\n  *\n  * @param {message}  message received in the messageBus\n  */\n  requestToIdp(msg) {\n    let _this = this;\n    let params = msg.body.params;\n\n    switch (msg.body.method) {\n      case 'generateAssertion':\n        idp.generateAssertion(params.contents, params.origin, params.usernameHint).then(\n          function(value) { _this.replyMessage(msg, value);},\n\n          function(error) { _this.replyMessage(msg, error);}\n        );\n        break;\n      case 'validateAssertion':\n        idp.validateAssertion(params.assertion, params.origin).then(\n          function(value) { _this.replyMessage(msg, value);},\n\n          function(error) { _this.replyMessage(msg, error);}\n        );\n        break;\n      default:\n        break;\n    }\n  }\n\n\n  /**\n  * This function receives a message and a value. It replies the value to the sender of the message received\n  *\n  * @param  {message}   message received\n  * @param  {value}     value to include in the new message to send\n  */\n  replyMessage(msg, value) {\n    let _this = this;\n\n    let message = {id: msg.id, type: 'response', to: msg.from, from: msg.to,\n                   body: {code: 200, value: value}};\n\n    _this.messageBus.postMessage(message);\n  }\n}\n\n// export default IdpProxyProtoStub;\n\n/**\n * To activate this protocol stub, using the same method for all protostub.\n * @param  {URL.RuntimeURL}                            runtimeProtoStubURL runtimeProtoSubURL\n * @param  {Message.Message}                           busPostMessage     configuration\n * @param  {ProtoStubDescriptor.ConfigurationDataList} configuration      configuration\n * @return {Object} Object with name and instance of ProtoStub\n */\nexport default function activate(url, bus, config) {\n  return {\n    name: 'RethinkOidcProtoStub',\n    instance: new RethinkOidcProtoStub(url, bus, config)\n  };\n}\n"],"sourceRoot":"/source/"}