{"version":3,"sources":["runtime-catalogue/RuntimeCatalogue.js"],"names":["_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_utils","require","_CatalogueDataObjectFactory","_CatalogueDataObjectFactory2","_PersistenceManager","_PersistenceManager2","RuntimeCatalogue","runtimeFactory","this","Error","_this","_factory","undefined","httpRequest","createHttpRequest","atob","descriptorURL","createFunc","Promise","resolve","reject","get","then","result","getVersion","JSON","parse","e","set","version","reason","hypertyURL","getDescriptor","_createHyperty","stubURL","dividedURL","divideURL","type","domain","protostub","identity","substring","lastIndexOf","prefix","includes","_createStub","runtimeURL","_createRuntimeDescriptor","dataSchemaURL","_createDataSchema","idpProxyURL","idpproxy","originDividedURL","originDomain","_createIdpProxy","rawHyperty","hyperty","createHypertyDescriptorObject","configuration","constraints","messageSchema","policies","signature","sourcePackage","_createSourcePackage","rawStub","stub","createProtoStubDescriptorObject","rawRuntime","runtime","createHypertyRuntimeDescriptorObject","rawSchema","dataSchema","createHypertyDataObjectSchema","createMessageDataObjectSchema","sourceCode","getSourcePackageFromURL","sourcePackageURL","rawProxy","sp","createSourcePackage","encoding","console","warn","url","_runtimeURL","module"],"mappings":"AAAA,YAAm6B,SAASA,wBAAuBC,GAAK,MAAOA,IAAKA,EAAIC,WAAWD,GAAKE,UAAQF,GAAM,QAASG,iBAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAnlCC,OAAOC,eAAeC,QAAQ,cAAcC,OAAM,GAAO,IAAIC,cAAa,WAAW,QAASC,GAAiBC,EAAOC,GAAO,IAAI,GAAIC,GAAE,EAAEA,EAAED,EAAME,OAAOD,IAAI,CAAC,GAAIE,GAAWH,EAAMC,EAAGE,GAAWC,WAAWD,EAAWC,aAAY,EAAMD,EAAWE,cAAa,EAAQ,SAAUF,KAAWA,EAAWG,UAAS,GAAKb,OAAOC,eAAeK,EAAOI,EAAWI,IAAIJ,IAAc,MAAO,UAASZ,EAAYiB,EAAWC,GAAuI,MAAvHD,IAAWV,EAAiBP,EAAYmB,UAAUF,GAAeC,GAAYX,EAAiBP,EAAYkB,GAAoBlB,MAAljBoB,OAAAC,QAAA,kBACAC,4BAAAD,QAAA,mDADwsBE,6BAA6B7B,uBAAuB4B,6BAE5vBE,oBAAAH,QAAA,qCAFk2BI,qBAAqB/B,uBAAuB8B,qBAIx4BE,iBAJspC,WAMxpC,QAAAA,GAAYC,GACR,GADwB7B,gBAAA8B,KAAAF,IACnBC,EAAgB,KAAME,OAAM,yCAEjC,IAAIC,GAAQF,IACZE,GAAMC,SAAW,GAAAR,8BAAAA,aAAqB,IAAOS,SAC7CF,EAAMG,YAAcN,EAAeO,oBACnCJ,EAAMK,KAAOR,EAAeQ,KAAOR,EAAeQ,KAAOA,KAkGgW,MAzG1Z7B,cAAaoB,IAAmBV,IAAI,gBAAgBX,MAAM,SAgB/C+B,EAAeC,GACzB,GAAIP,GAAQF,IAGZ,OAAO,IAAIU,SAAQ,SAAUC,EAASC,GAElCV,EAAMG,YAAYQ,IAAIL,EAAgB,YAAYM,KAAK,SAAUC,GACzDlB,qBAAAA,WAAmBmB,WAAWR,IAAkBO,EAGhDJ,EAAQF,EAAWP,EAAOL,qBAAAA,WAAmBgB,IAAIL,KAGjDN,EAAMG,YAAYQ,IAAIL,GAAeM,KAAK,SAAUC,GAIhD,GAHAA,EAASE,KAAKC,MAAMH,GAGhBA,EAAA,MAEAH,EAAOG,OACJ,CAEH,IAAK,GAAI3B,KAAO2B,GACZ,IACIA,EAAO3B,GAAO6B,KAAKC,MAAMH,EAAO3B,IAClC,MAAO+B,IAKb,GAAInC,GAAayB,EAAWP,EAAOa,EACnClB,sBAAAA,WAAmBuB,IAAIZ,EAAexB,EAAWqC,QAASN,GAE1DJ,EAAQ3B,QA3BxBkB,SA+BS,SAASoB,GAChBV,EAAOU,UAzCXlC,IAAI,uBAAuBX,MAAM,SAmDlB8C,GACjB,GAAIrB,GAAQF,IACZ,OAAOE,GAAMsB,cAAcD,EAAYrB,EAAMuB,mBAjD3CrC,IAAI,oBAAoBX,MAAM,SAyDlBiD,GACd,GAAIxB,GAAQF,KAER2B,GAAa,EAAAnC,OAAAoC,WAAUF,GACvBG,EAAOF,EAAWE,KAClBC,EAASH,EAAWG,OACpBC,EAAYJ,EAAWK,QAKzBD,GAHGA,EAGSA,EAAUE,UAAUF,EAAUG,YAAY,KAAO,GAFjD,SAKd,IAAIC,GAAS,YAOb,OANIT,GAAQU,SAAS,eACnBD,EAAS,IAGXT,EAAUG,EAAO,MAAQM,EAAUL,EAAS,6BAA+BC,EAEpE7B,EAAMsB,cAAcE,EAASxB,EAAMmC,gBA1ExCjD,IAAI,uBAAuBX,MAAM,SAkFlB6D,GACjB,GAAIpC,GAAQF,IACZ,OAAOE,GAAMsB,cAAcc,EAAYpC,EAAMqC,6BAhF3CnD,IAAI,0BAA0BX,MAAM,SAwFlB+D,GACpB,GAAItC,GAAQF,IACZ,OAAOE,GAAMsB,cAAcgB,EAAetC,EAAMuC,sBAtF9CrD,IAAI,wBAAwBX,MAAM,SA8FlBiE,GACpB,GAAIxC,GAAQF,IAEZ,OAAO,IAAIU,SAAQ,SAASC,EAASC,GAEnC,GAAIe,IAAa,EAAAnC,OAAAoC,WAAUc,GACvBb,EAAOF,EAAWE,KAClBC,EAASH,EAAWG,OACpBa,EAAWhB,EAAWK,SAEtBY,GAAmB,EAAApD,OAAAoC,WAAU1B,EAAMoC,YACnCO,EAAeD,EAAiBd,MAE/BA,KACHA,EAASY,GAMTC,EAHEb,IAAWe,GAAiBF,EAGnBA,EAASV,UAAUU,EAAST,YAAY,KAAO,GAF/C,SAKb,IAAIC,GAAS,YAOb,OANIO,GAAYN,SAAS,eACvBD,EAAS,IAGXO,EAAcb,EAAO,MAAQC,EAAS,0BAA4Ba,EAE3DzC,EAAMsB,cAAckB,EAAaxC,EAAM4C,iBAAiBhC,KAAK,SAASC,GAG3EJ,EAAQI,KAHHb,SAKE,WAQP,MANAyC,GAAWb,EACXA,EAASe,EAGTH,EAAcb,EAAO,MAAQM,EAASL,EAAS,0BAA4Ba,EAEpEzC,EAAMsB,cAAckB,EAAaxC,EAAM4C,mBAC7ChC,KAAK,SAASC,GACfJ,EAAQI,KAfHb,SAgBE,SAASoB,GAChBV,EAAOU,UAtIPlC,IAAI,iBAAiBX,MAAM,SAkJlByB,EAAO6C,GAElB,GAAIC,GAAU9C,EAAMC,SAAS8C,8BACzBF,EAAA,MACAA,EAAA,QACAA,EAAA,WACAA,EAAA,YACAA,EAAA,SACAA,EAAA,iBACAA,EAAA,MAAsBA,EAAA,YACtBA,EAAA,YAIJC,GAAQE,cAAgBH,EAAA,cACxBC,EAAQG,YAAcJ,EAAA,YACtBC,EAAQI,cAAgBL,EAAA,cACxBC,EAAQK,SAAWN,EAAA,SACnBC,EAAQM,UAAYP,EAAA,SAGpB,IAAIQ,GAAgBR,EAAA,aAMpB,OALIQ,KAEAP,EAAQO,cAAgBrD,EAAMsD,qBAAqBtD,EAAOqD,IAGvDP,KApKL5D,IAAI,cAAcX,MAAM,SA6KlByB,EAAOuD,GAIf,GAAIC,GAAOxD,EAAMC,SAASwD,gCACtBF,EAAA,MACAA,EAAA,QACAA,EAAA,WACAA,EAAA,YACAA,EAAA,SACAA,EAAA,iBACAA,EAAA,eACAA,EAAA,cACAA,EAAA,YAIJC,GAAKJ,UAAYG,EAAA,SAGjB,IAAIF,GAAgBE,EAAA,aAMpB,OALIF,KACAA,EAAgBrD,EAAMsD,qBAAqBtD,EAAOqD,GAClDG,EAAKH,cAAgBA,GAGlBG,KA9LLtE,IAAI,2BAA2BX,MAAM,SAuMlByB,EAAO0D,GAE5B,IACIA,EAAA,oBAAoC3C,KAAKC,MAAM0C,EAAA,qBAC/CA,EAAA,qBAAqC3C,KAAKC,MAAM0C,EAAA,sBAClD,MAAOzC,IAOT,GAAI0C,GAAU3D,EAAMC,SAAS2D,qCACzBF,EAAA,MACAA,EAAA,QACAA,EAAA,WACAA,EAAA,YACAA,EAAA,SACAA,EAAA,iBACAA,EAAA,MAAsBA,EAAA,YACtBA,EAAA,oBACAA,EAAA,qBAIJC,GAAQP,UAAYM,EAAA,SAGpB,IAAIL,GAAgBK,EAAA,aAKpB,OAJIL,KAEAM,EAAQN,cAAgBrD,EAAMsD,qBAAqBtD,EAAOqD,IAEvDM,KA5NLzE,IAAI,oBAAoBX,MAAM,SAqOlByB,EAAO6D,GAGrB,GAAIC,GAAA,MAIAA,GADAD,EAAA,qBAAoCA,EAAA,OACvB7D,EAAMC,SAAS8D,8BACxBF,EAAA,MACAA,EAAA,QACAA,EAAA,WACAA,EAAA,YACAA,EAAA,SACAA,EAAA,iBACAA,EAAA,oBACAA,EAAA,QAIS7D,EAAMC,SAAS+D,8BACxBH,EAAA,MACAA,EAAA,QACAA,EAAA,WACAA,EAAA,YACAA,EAAA,SACAA,EAAA,kBAKRC,EAAWV,UAAYS,EAAA,SAGvB,IAAIR,GAAgBQ,EAAA,aACpB,IAAIR,EAAe,CAEfS,EAAWT,cAAgBrD,EAAMsD,qBAAqBtD,EAAOqD,EAE7D,KACES,EAAWT,cAAcY,WAAalD,KAAKC,MAAM8C,EAAWT,cAAcY,YAC1E,MAAOhD,IAIT,MAAO6C,GAKT,MAAO,IAAItD,SAAQ,SAASC,EAASC,GAEnCV,EAAMkE,wBAAwBL,EAAUM,kBAAkBvD,KAAK,SAASyC,GAEtES,EAAWT,cAAgBA,EAC3B5C,EAAQqD,KAHV9D,SAIS,SAASoB,GAEhBV,EAAOU,UA5QXlC,IAAI,kBAAkBX,MAAM,SA0RlByB,EAAOoE,GAInB,GAAI3B,GAAWzC,EAAMC,SAASwD,gCAC1BW,EAAA,MACAA,EAAA,QACAA,EAAA,WACAA,EAAA,YACAA,EAAA,SACAA,EAAA,iBACAA,EAAA,eACAA,EAAA,cACAA,EAAA,YAIJ3B,GAASW,UAAYgB,EAAA,SAGrB,IAAIf,GAAgBe,EAAA,aAMpB,OALIf,KACAA,EAAgBrD,EAAMsD,qBAAqBtD,EAAOqD,GAClDZ,EAASY,cAAgBA,GAGtBZ,KAhTuKvD,IAAI,uBAAuBX,MAAM,SAmT9LyB,EAAOqE,GACxB,IACIA,EAAKtD,KAAKC,MAAMqD,GAClB,MAAOpD,IAKc,WAAnBoD,EAAA,WACFA,EAAA,WAAmBrE,EAAMK,KAAKgE,EAAA,YAC9BA,EAAA,SAAiB,QAGnB,IAAIhB,GAAgBrD,EAAMC,SAASqE,oBAAoBD,EAAA,oBAA2BA,EAAA,WAOlF,OANIA,GAAA,WACAhB,EAAckB,SAAWF,EAAA,UAEzBA,EAAA,YACAhB,EAAcD,UAAYiB,EAAA,WAEvBhB,KAjULnE,IAAI,0BAA0BX,MAAM,SAyUlB4F,GACpB,GAAInE,GAAQF,IAOZ,OAJA0E,SAAQC,KAAK,+FACbD,QAAQC,KAAK,+FACbD,QAAQC,KAAK,+FAEN,GAAIjE,SAAQ,SAAUC,EAASC,GAClCV,EAAMG,YAAYQ,IAAIwD,GAAkBvD,KAAK,SAAUC,GAEnD,GAAIA,EAAA,MAEAH,EAAOG,OACJ,CACHA,EAASE,KAAKC,MAAMH,EACpB,IAAIwC,GAAgBrD,EAAMsD,qBAAqBtD,EAAOa,EACtDJ,GAAQ4C,MARhBrD,SAUS,SAAUoB,GACfV,EAAOU,UAtVblC,IAAI,8BAA8BX,MAAM,SAkWlBO,GACxB,GAAIkB,GAAQF,IACZ,OAAO,IAAIU,SAAQ,SAAUC,EAASC,GAC9B5B,EAAWuE,cAGX5C,EAAQ3B,EAAWuE,cAAcY,YAE7BtE,qBAAAA,WAAmBmB,WAAWhC,EAAWqF,iBAAmB,gBAAkBrF,EAAWqC,QAEzFV,EAAQd,qBAAAA,WAAmBgB,IAAI7B,EAAWqF,iBAAmB,gBAE7DnE,EAAMG,YAAYQ,IAAI7B,EAAWqF,iBAAmB,eAAevD,KAAK,SAAUqD,GAC1EA,EAAA,MAEAvD,EAAOuD,IAEPtE,qBAAAA,WAAmBuB,IAAIpC,EAAWqF,iBAAmB,cAAerF,EAAWqC,QAAS8C,GACxFxD,EAAQwD,WAhXgI/E,IAAI,eAAeX,MAAM,SAkY5KmG,GACT/E,qBAAAA,WAAAA,UAA0B+E,MAnYmOxF,IAAI,aAAagC,IAAI,SAwXvQkB,GACX,GAAIpC,GAAQF,IACZE,GAAM2E,YAAcvC,GA1XqUzB,IAAI,WA8X7V,GAAIX,GAAQF,IACZ,OAAOE,GAAM2E,gBA/XmZ/E,IAAqBtB,SAAAA,WAwY9asB,iBAxY+cgF,OAAOtG,QAAQA,QAAQ","file":"runtime-catalogue/RuntimeCatalogue.js","sourcesContent":["import {divideURL} from '../utils/utils';\nimport CatalogueFactory from '../catalogue-factory/CatalogueDataObjectFactory';\nimport persistenceManager from '../persistence/PersistenceManager';\n\nclass RuntimeCatalogue {\n\n    constructor(runtimeFactory) {\n        if (!runtimeFactory) throw Error('The catalogue needs the runtimeFactory');\n\n        let _this = this;\n        _this._factory = new CatalogueFactory(false, undefined);\n        _this.httpRequest = runtimeFactory.createHttpRequest();\n        _this.atob = runtimeFactory.atob ? runtimeFactory.atob : atob;\n    }\n\n    /**\n     * Get a Catalogue Data Object (Descriptor) from a URL, and construct it using the provided function\n     * @param {String} descriptorURL - e.g. mydomain.com/.well-known/hyperty/MyHyperty\n     * @param {function} createFunc - e.g. _createHyperty\n     * @returns {Promise}\n     */\n    getDescriptor(descriptorURL, createFunc) {\n        let _this = this;\n        // // console.log(\"getDescriptor\", descriptorURL);\n\n        return new Promise(function (resolve, reject) {\n\n            _this.httpRequest.get(descriptorURL + \"/version\").then(function (result) {\n                if (persistenceManager.getVersion(descriptorURL) >= result) {\n                    // return saved version\n                    // console.log(\"returning saved version:\", persistenceManager.get(descriptorURL));\n                    resolve(createFunc(_this, persistenceManager.get(descriptorURL)))\n                } else {\n                    // request the json\n                    _this.httpRequest.get(descriptorURL).then(function (result) {\n                        result = JSON.parse(result);\n\n\n                        if (result[\"ERROR\"]) {\n                            // TODO handle error properly\n                            reject(result);\n                        } else {\n                            // FIXME hotfix for unparsed arrays (e.g. hypertyType), will be fixed in Catalogue 1.1.0\n                            for (var key in result) {\n                                try {\n                                    result[key] = JSON.parse(result[key]);\n                                } catch (e) {\n                                    // do nothing\n                                }\n                            }\n                            // // console.log(\"creating descriptor based on: \", result);\n                            let descriptor = createFunc(_this, result);\n                            persistenceManager.set(descriptorURL, descriptor.version, result);\n                            // // console.log(\"created descriptor object:\", hyperty);\n                            resolve(descriptor);\n                        }\n                    });\n                }\n            }).catch(function(reason) {\n              reject(reason);\n            });\n        });\n    }\n\n    /**\n     * Get HypertyDescriptor\n     * @param hypertyURL - e.g. mydomain.com/.well-known/hyperty/MyHyperty\n     * @returns {Promise}\n     */\n    getHypertyDescriptor(hypertyURL) {\n        let _this = this;\n        return _this.getDescriptor(hypertyURL, _this._createHyperty)\n    }\n\n    /**\n     * Get StubDescriptor\n     * @param stubURL - e.g. mydomain.com/.well-known/protostub/MyProtostub\n     * @returns {Promise}\n     */\n    getStubDescriptor(stubURL) {\n        let _this = this;\n\n        let dividedURL = divideURL(stubURL);\n        let type = dividedURL.type;\n        let domain = dividedURL.domain;\n        let protostub = dividedURL.identity;\n\n        if (!protostub) {\n          protostub = 'default';\n        } else {\n          protostub = protostub.substring(protostub.lastIndexOf('/') + 1);\n        }\n\n        let prefix = 'catalogue.'\n        if (stubURL.includes('catalogue')) {\n          prefix = '';\n        }\n\n        stubURL = type + '://' + prefix  + domain + '/.well-known/protocolstub/' + protostub;\n\n        return _this.getDescriptor(stubURL, _this._createStub)\n    }\n\n    /**\n     * Get RuntimeDescriptor\n     * @param runtimeURL - e.g. mydomain.com/.well-known/runtime/MyRuntime\n     * @returns {Promise}\n     */\n    getRuntimeDescriptor(runtimeURL) {\n        let _this = this;\n        return _this.getDescriptor(runtimeURL, _this._createRuntimeDescriptor)\n    }\n\n    /**\n     * Get DataSchemaDescriptor\n     * @param dataSchemaURL - e.g. mydomain.com/.well-known/dataschema/MyDataSchema\n     * @returns {Promise}\n     */\n    getDataSchemaDescriptor(dataSchemaURL) {\n        let _this = this;\n        return _this.getDescriptor(dataSchemaURL, _this._createDataSchema)\n    }\n\n    /**\n     * Get IDPProxyDescriptor\n     * @param idpProxyURL - e.g. mydomain.com/.well-known/idp-proxy/MyProxy\n     * @returns {Promise}\n     */\n    getIdpProxyDescriptor(idpProxyURL) {\n      let _this = this;\n\n      return new Promise(function(resolve, reject) {\n\n        let dividedURL = divideURL(idpProxyURL);\n        let type = dividedURL.type;\n        let domain = dividedURL.domain;\n        let idpproxy = dividedURL.identity;\n\n        let originDividedURL = divideURL(_this.runtimeURL);\n        let originDomain = originDividedURL.domain;\n\n        if (!domain) {\n          domain = idpProxyURL;\n        }\n\n        if (domain === originDomain || !idpproxy) {\n          idpproxy = 'default';\n        } else {\n          idpproxy = idpproxy.substring(idpproxy.lastIndexOf('/') + 1);\n        }\n\n        let prefix = 'catalogue.'\n        if (idpProxyURL.includes('catalogue')) {\n          prefix = '';\n        }\n\n        idpProxyURL = type + '://' + domain + '/.well-known/idp-proxy/' + idpproxy;\n\n        return _this.getDescriptor(idpProxyURL, _this._createIdpProxy).then(function(result) {\n\n          // console.log('result: ', result);\n          resolve(result);\n\n        }).catch(function() {\n\n          idpproxy = domain;\n          domain = originDomain;\n\n          // console.log('Get an specific protostub for domain', domain, ' specific for: ', idpproxy);\n          idpProxyURL = type + '://' + prefix + domain + '/.well-known/idp-proxy/' + idpproxy;\n\n          return _this.getDescriptor(idpProxyURL, _this._createIdpProxy);\n        }).then(function(result) {\n          resolve(result);\n        }).catch(function(reason) {\n          reject(reason);\n        });\n\n      });\n    }\n\n    /**\n     * Create HypertyDescriptor based on raw object that contains its attributes\n     * @param _this\n     * @param rawHyperty\n     * @returns {HypertyDescriptor}\n     */\n    _createHyperty(_this, rawHyperty) {\n        // create the descriptor\n        let hyperty = _this._factory.createHypertyDescriptorObject(\n            rawHyperty[\"cguid\"],\n            rawHyperty[\"version\"],\n            rawHyperty[\"objectName\"],\n            rawHyperty[\"description\"],\n            rawHyperty[\"language\"],\n            rawHyperty[\"sourcePackageURL\"],\n            rawHyperty[\"type\"] || rawHyperty[\"hypertyType\"],\n            rawHyperty[\"dataObjects\"]\n        );\n\n        // optional fields\n        hyperty.configuration = rawHyperty[\"configuration\"];\n        hyperty.constraints = rawHyperty[\"constraints\"];\n        hyperty.messageSchema = rawHyperty[\"messageSchema\"];\n        hyperty.policies = rawHyperty[\"policies\"];\n        hyperty.signature = rawHyperty[\"signature\"];\n\n        // parse and attach sourcePackage\n        let sourcePackage = rawHyperty[\"sourcePackage\"];\n        if (sourcePackage) {\n            // // console.log(\"hyperty has sourcePackage:\", sourcePackage);\n            hyperty.sourcePackage = _this._createSourcePackage(_this, sourcePackage);\n        }\n\n        return hyperty;\n    }\n\n    /**\n     * Create ProtocolStubDescriptor based on raw object that contains its attributes\n     * @param _this\n     * @param rawStub\n     * @returns {ProtocolStubDescriptor}\n     */\n    _createStub(_this, rawStub) {\n        // // console.log(\"creating stub descriptor based on: \", rawStub);\n\n        // create the descriptor\n        let stub = _this._factory.createProtoStubDescriptorObject(\n            rawStub[\"cguid\"],\n            rawStub[\"version\"],\n            rawStub[\"objectName\"],\n            rawStub[\"description\"],\n            rawStub[\"language\"],\n            rawStub[\"sourcePackageURL\"],\n            rawStub[\"messageSchemas\"],\n            rawStub[\"configuration\"],\n            rawStub[\"constraints\"]\n        );\n\n        // optional fields\n        stub.signature = rawStub[\"signature\"];\n\n        // parse and attach the sourcePackage\n        let sourcePackage = rawStub[\"sourcePackage\"];\n        if (sourcePackage) {\n            sourcePackage = _this._createSourcePackage(_this, sourcePackage);\n            stub.sourcePackage = sourcePackage;\n        }\n\n        return stub;\n    }\n\n    /**\n     * Create HypertyRuntimeDescriptor based on raw object that contains its attributes\n     * @param _this\n     * @param rawRuntime\n     * @returns {HypertyRuntimeDescriptor}\n     */\n    _createRuntimeDescriptor(_this, rawRuntime) {\n        // parse capabilities first\n        try {\n            rawRuntime[\"hypertyCapabilities\"] = JSON.parse(rawRuntime[\"hypertyCapabilities\"]);\n            rawRuntime[\"protocolCapabilities\"] = JSON.parse(rawRuntime[\"protocolCapabilities\"]);\n        } catch (e) {\n            // already json object\n        }\n        // console.log(\"creating runtime descriptor based on: \", rawRuntime);\n\n\n        // create the descriptor\n        let runtime = _this._factory.createHypertyRuntimeDescriptorObject(\n            rawRuntime[\"cguid\"],\n            rawRuntime[\"version\"],\n            rawRuntime[\"objectName\"],\n            rawRuntime[\"description\"],\n            rawRuntime[\"language\"],\n            rawRuntime[\"sourcePackageURL\"],\n            rawRuntime[\"type\"] || rawRuntime[\"runtimeType\"],\n            rawRuntime[\"hypertyCapabilities\"],\n            rawRuntime[\"protocolCapabilities\"]\n        );\n\n        // optional fields\n        runtime.signature = rawRuntime[\"signature\"];\n\n        // parse and attach sourcePackage\n        let sourcePackage = rawRuntime[\"sourcePackage\"];\n        if (sourcePackage) {\n            // // console.log(\"runtime has sourcePackage:\", sourcePackage);\n            runtime.sourcePackage = _this._createSourcePackage(_this, sourcePackage);\n        }\n        return runtime;\n    }\n\n    /**\n     * Create DataObjectSchema based on raw object that contains its attributes\n     * @param _this\n     * @param rawSchema\n     * @returns {DataObjectSchema}\n     */\n    _createDataSchema(_this, rawSchema) {\n        // console.log(\"creating dataSchema based on: \", rawSchema);\n\n        let dataSchema;\n        // console.log('1. createMessageDataObjectSchema: ', rawSchema[\"accessControlPolicy\"]);\n        // console.log('2. createMessageDataObjectSchema: ', rawSchema[\"scheme\"]);\n        if (rawSchema[\"accessControlPolicy\"] && rawSchema[\"scheme\"]) {\n            dataSchema = _this._factory.createHypertyDataObjectSchema(\n                rawSchema[\"cguid\"],\n                rawSchema[\"version\"],\n                rawSchema[\"objectName\"],\n                rawSchema[\"description\"],\n                rawSchema[\"language\"],\n                rawSchema[\"sourcePackageURL\"],\n                rawSchema[\"accessControlPolicy\"],\n                rawSchema[\"scheme\"]\n            )\n        } else {\n          // console.log('3. createMessageDataObjectSchema: ', rawSchema);\n            dataSchema = _this._factory.createMessageDataObjectSchema(\n                rawSchema[\"cguid\"],\n                rawSchema[\"version\"],\n                rawSchema[\"objectName\"],\n                rawSchema[\"description\"],\n                rawSchema[\"language\"],\n                rawSchema[\"sourcePackageURL\"]\n            )\n        }\n\n        // optional fields\n        dataSchema.signature = rawSchema[\"signature\"];\n\n        // parse and attach sourcePackage\n        let sourcePackage = rawSchema[\"sourcePackage\"];\n        if (sourcePackage) {\n            // console.log(\"dataSchema has sourcePackage:\", sourcePackage);\n            dataSchema.sourcePackage = _this._createSourcePackage(_this, sourcePackage);\n\n            try {\n              dataSchema.sourcePackage.sourceCode = JSON.parse(dataSchema.sourcePackage.sourceCode);\n            } catch (e) {\n              // console.log('DataSchema Source code is already parsed');\n            }\n\n            return dataSchema;\n\n        } else {\n          // console.log('4. getSourcePackageFromURL: ', rawSchema.sourcePackageURL);\n\n          return new Promise(function(resolve, reject) {\n\n            _this.getSourcePackageFromURL(rawSchema.sourcePackageURL).then(function(sourcePackage) {\n              // console.log('5. result of getSourcePackageFromURL', sourcePackage);\n              dataSchema.sourcePackage = sourcePackage;\n              resolve(dataSchema);\n            }).catch(function(reason) {\n              // console.log('Error getting the sourcePackageURL ', reason);\n              reject(reason);\n            });\n          })\n        }\n        // // console.log(\"created dataSchema descriptor object:\", dataSchema);\n        // return dataSchema;\n    }\n\n    /**\n     * Create ProtocolStubDescriptor based on raw object that contains its attributes\n     * @param _this\n     * @param rawProxy\n     * @returns {ProtocolStubDescriptor}\n     */\n    _createIdpProxy(_this, rawProxy) {\n        // // console.log(\"creating idpproxy descriptor based on: \", rawProxy);\n\n        // create the descriptor\n        let idpproxy = _this._factory.createProtoStubDescriptorObject(\n            rawProxy[\"cguid\"],\n            rawProxy[\"version\"],\n            rawProxy[\"objectName\"],\n            rawProxy[\"description\"],\n            rawProxy[\"language\"],\n            rawProxy[\"sourcePackageURL\"],\n            rawProxy[\"messageSchemas\"],\n            rawProxy[\"configuration\"],\n            rawProxy[\"constraints\"]\n        );\n\n        // optional fields\n        idpproxy.signature = rawProxy[\"signature\"];\n\n        // parse and attach the sourcePackage\n        let sourcePackage = rawProxy[\"sourcePackage\"];\n        if (sourcePackage) {\n            sourcePackage = _this._createSourcePackage(_this, sourcePackage);\n            idpproxy.sourcePackage = sourcePackage;\n        }\n\n        return idpproxy;\n    }\n\n    _createSourcePackage(_this, sp) {\n        try {\n            sp = JSON.parse(sp);\n        } catch (e) {\n            // console.log(\"parsing sourcePackage failed. already parsed? -> \", sp);\n        }\n\n        // check encoding\n        if (sp[\"encoding\"] === \"base64\") {\n          sp[\"sourceCode\"] = _this.atob(sp[\"sourceCode\"])\n          sp[\"encoding\"] = \"UTF-8\";\n        }\n\n        let sourcePackage = _this._factory.createSourcePackage(sp[\"sourceCodeClassname\"], sp[\"sourceCode\"]);\n        if (sp[\"encoding\"])\n            sourcePackage.encoding = sp[\"encoding\"];\n\n        if (sp[\"signature\"])\n            sourcePackage.signature = sp[\"signature\"];\n\n        return sourcePackage;\n    }\n\n    /**\n     * Get source Package from a URL\n     * @param sourcePackageURL - e.g. mydomain.com/.well-known/hyperty/MyHyperty/sourcePackage\n     * @returns {Promise}\n     */\n    getSourcePackageFromURL(sourcePackageURL) {\n        let _this = this;\n\n        // console.log(\"getting sourcePackage from:\", sourcePackageURL);\n        console.warn(\"-------------------------------------------------------------------------------------------\");\n        console.warn(\"ATTENTION: This function may fail if the sourceCode of the the sourcePackage is very large!\");\n        console.warn(\"-------------------------------------------------------------------------------------------\");\n\n        return new Promise(function (resolve, reject) {\n            _this.httpRequest.get(sourcePackageURL).then(function (result) {\n                //// console.log(\"got raw sourcePackage:\", result);\n                if (result[\"ERROR\"]) {\n                    // TODO handle error properly\n                    reject(result);\n                } else {\n                    result = JSON.parse(result);\n                    let sourcePackage = _this._createSourcePackage(_this, result);\n                    resolve(sourcePackage);\n                }\n            }).catch(function (reason) {\n                reject(reason);\n            });\n\n        });\n\n    }\n\n    /**\n     * Returns the sourceCode of a given descriptor\n     * @param {CatalogueDataObject} descriptor - Catalogue Object that was retrieved using e.g. getHypertyDescriptor()\n     * @returns {Promise}\n     */\n    getSourceCodeFromDescriptor(descriptor) {\n        let _this = this;\n        return new Promise(function (resolve, reject) {\n            if (descriptor.sourcePackage) {\n                //// console.log(\"descriptor has sourcePackage\");\n                //// console.log(\"returning sourceCode:\", descriptor.sourcePackage.sourceCode);\n                resolve(descriptor.sourcePackage.sourceCode);\n            } else {\n                if (persistenceManager.getVersion(descriptor.sourcePackageURL + \"/sourceCode\") >= descriptor.version) {\n                    // console.log(\"returning cached version from persistence manager\");\n                    resolve(persistenceManager.get(descriptor.sourcePackageURL + \"/sourceCode\"));\n                } else {\n                    _this.httpRequest.get(descriptor.sourcePackageURL + \"/sourceCode\").then(function (sourceCode) {\n                        if (sourceCode[\"ERROR\"]) {\n                            // TODO handle error properly\n                            reject(sourceCode);\n                        } else {\n                            persistenceManager.set(descriptor.sourcePackageURL + \"/sourceCode\", descriptor.version, sourceCode);\n                            resolve(sourceCode);\n                        }\n                    });\n                }\n            }\n        });\n    }\n\n    set runtimeURL(runtimeURL) {\n        let _this = this;\n        _this._runtimeURL = runtimeURL;\n    }\n\n    get runtimeURL() {\n        let _this = this;\n        return _this._runtimeURL;\n    }\n\n    deleteFromPM(url) {\n        persistenceManager.delete(url);\n    }\n\n}\n\nexport default RuntimeCatalogue;\n"],"sourceRoot":"/source/"}