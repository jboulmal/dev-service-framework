/*
 * generated by Xtext
 */
package rethink.uml.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import rethink.uml.classDiagram.Clazz
import rethink.uml.classDiagram.Relation
import rethink.uml.classDiagram.CompType
import rethink.uml.classDiagram.Enumer
import java.util.List
import rethink.uml.classDiagram.EntityAndNote
import rethink.uml.classDiagram.Entity

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ClassDiagramGenerator implements IGenerator {
	
	@Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for(clazz: resource.allContents.filter(Clazz).toIterable) {
			val relations = resource.allContents.filter(Relation).filter[
				if(leftRef == clazz && rightRef instanceof Entity)
					return true
				
				return false
			].toList

			val invRelations = resource.allContents.filter(Relation).filter[
				if(rightRef == clazz && leftRef instanceof Entity && relType.direct == false)
					return true
				
				return false
			].toList
			
    		fsa.generateFile(clazz.fullyQualifiedName.toString("/") + ".json", compile(clazz, relations, invRelations))
      	}
	}
	
	def compile(Clazz clazz, List<Relation> relations, List<Relation> invRelations) {
		//required properties...
		val required = clazz.properties.filter[!optional].map[name].toList
		
		//required relations...
		required.addAll(relations.filter[
			relType.multi != null && relType.multi.contains("1") && !relType.multi.contains("0") ||
			relType.comp == CompType.NONE
		].map[relationName(false)])
		
		return '''
			{
				"id": "«clazz.name»",
				"$schema": "http://json-schema.org/draft-04/schema#",
				"type": "object",
				«IF !required.empty»
					"required": [«FOR prop:required SEPARATOR ", "»"«prop»"«ENDFOR»],
				«ENDIF»
				"additionalProperties": false,
				"properties": {
					«FOR prop:clazz.properties SEPARATOR ','»
						"«prop.name»": {
							"type": "«prop.type»"
						}
					«ENDFOR»
					«IF !relations.empty»
						«IF !clazz.properties.empty»,«ENDIF»
						«FOR rel:relations SEPARATOR ","»
							"«rel.relationName(false)»": {
								«processRelation(rel.rightRef, rel.relType.comp, rel.relType.multi) »
							}
						«ENDFOR»
					«ENDIF»
					«IF !invRelations.empty»
						«IF !clazz.properties.empty || !relations.empty»,«ENDIF»
						«FOR rel:invRelations SEPARATOR ","»
							"«rel.relationName(true)»": {
								«processRelation(rel.leftRef, CompType.NONE, "1")»
							}
						«ENDFOR»
					«ENDIF»
				}
			}
		'''
	}
	
	def relationName(Relation rel, boolean isInv) {
		if(isInv)
			return '''«rel.leftRef.name.toFirstLower»Inv'''
		else
			return '''«rel.rightRef.name.toFirstLower»«IF rel.relType.comp != CompType.NONE»Array«ENDIF»'''
	}
	
	def processRelation(EntityAndNote ref, CompType type, String multi) {
		var selector = 0
		if(multi != null && multi.contains("*") || multi == null && type != CompType.NONE) {
			selector = 1
		}
		
		switch(selector) {
			case 0: return processRef(ref)
			case 1: return '''
				"type": "array",
				"items": {
					«processRef(ref)»
				}
			'''
		}
	}
	
	def processRef(EntityAndNote ref) {
		if(ref instanceof Enumer) {
			return '''
				"enum": [
					«FOR eType:ref.types SEPARATOR ','»
						"«eType»"
					«ENDFOR»
				]
			'''
		} else {
			return '''
				"$ref": "«ref.name»"
			'''
		}
	}

}
